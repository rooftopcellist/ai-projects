'''
Markov NN for smart word generation
Author: Christian M. Adams

Create a word generator for a language whose example words are {spare, spear, pares, peers, reaps, peaks, speaker, keeper, pester, paste, tapas, pasta, past, straps, tears, terse, steer, street, stare, rates, streak, taste, tapa, peat, eat, ate, tea, seat}.
       Use your program to generate at least 100 random words.
        Are any words repeated?

        What is the probability of generation for each word?

        What are the shortest and longest words generated?

        What is the longest word that can be generated and what is the probability of its occurrence? If you cannot answer this directly, can you provide a bound for the probability of occurrence?

       Use the words generated by your program to create a second Markov model and compare the transition probabilities of the two models you created.
        Use you program to create two Markov models based on 500-word (or larger) writing samples from two, different languages
        (say, English and French, American and German, or possibly American and English). The writing samples are to be taken
          from web sites using different modern languages that are written using Latin letters.
          Compare the transition probabilities of the two models you create.

'''

import string
import numpy as np
import matplotlib.pyplot as plt
from random import randint, choice

#English Alphabet
ENGLISH = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
                   'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
                   's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
ENGLISH_END = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
                   'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
                   's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'END']

#Make lookup table for use with 2d matrices
ENG_LOOKUP = {}
count = 0
for let in ENGLISH:
	ENG_LOOKUP[let] = count
	count += 1
ENG_LOOKUP['END'] = count

# Sample Training Words
WORDS = ['spare', 'spear', 'pares', 'peers', 'reaps', 'peaks',
			'speaker', 'keeper', 'pester', 'paste', 'tapas', 'pasta',
			'past', 'straps', 'tears', 'terse', 'steer', 'street',
			'stare', 'rates', 'streak', 'taste', 'tapa', 'peat', 'eat',
			'ate', 'tea', 'seat']

#Letter Class (Not currently used)
class Letter:
    def __init__(self, char, count):
        self.char = char
        self.count = count

    def inc_count(self):
        self.count += self.count


#Reads in article using each word as input
def readArticle(path):
    with open(path, 'r') as f:
        for line in f:
            for word in line.split():
                cleanWord = word.translate(None, string.punctuation)
                WORDS.append(cleanWord)

readArticle('dictionary.txt')

#Records 1st letter probability
first_letter_prob = {}

for word in WORDS:
    first_letter = word[0]
    if first_letter in first_letter_prob:
        first_letter_prob[first_letter] += 1
    else:
        first_letter_prob[first_letter] = 1

print "The probability of each first letter is: \n", first_letter_prob, "\n\n"

#Populates array of all first letters to be randomly selected from
first_letter_array = []
for word in WORDS:
    first_letter_array.append(word[0])

print "All first letters: \n", first_letter_array, "\n\n"


#Create 2D Matrix for transition probabilities (including last letter-->END transtition)
n = len(ENGLISH) + 1
transition_prob = [[0] * n for i in range(n)]

#Populate 2D transition probability matrix
for word in WORDS:
	for i in range(len(word) - 1):
		transition_prob[ENG_LOOKUP[word[i]]][ENG_LOOKUP[word[i + 1]]] += 1
	transition_prob[ENG_LOOKUP[word[-1]]][ENG_LOOKUP['END']] += 1

print "Transition Probability Matrix\n", transition_prob, "\n\n"

#Write to CSV for later analysis in Excel
with open('csvfile.csv','wb') as file:
    for i in range(27):
        for value in transition_prob[i]:
            value = str(value) + ','
            file.write(value)
        file.write('\n')

def gen_prob():
    return randint(0,1000)/1000.

def pick_first_letter():
    return first_letter_array[randint(0, len(first_letter_array) - 1)]

def pick_next_letter(prev_letter):
    let_bank = []
    for i in range(27):
        temp = transition_prob[ENG_LOOKUP[prev_letter]][i]
        letter = ENGLISH_END[i]
        while temp > 0:
            let_bank.append(letter)
            temp -= 1
    return choice(let_bank)


#Roulette wheel selection approach to generating a word
def generate_word():

    new_word = pick_first_letter()
    # pick_next_letter(new_word[-1])
    n_letter = pick_next_letter(new_word[-1])
    while n_letter != 'END':
        new_word = new_word + n_letter
        n_letter = pick_next_letter(new_word[-1])
    return new_word
generate_word()

# def generate_prob_word():
#     new_word = pick_first_letter()
#     pick_next_prob_letter
#
# generate_prob_word()





count = 0
while count < 50:
    print generate_word()
    count += 1

transition_prob
